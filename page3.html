---
title: Page One
layout: default
---
<h1>Enhancement Two Narrative</h1>
<p>
For enhancement Category Two, I chose an artifact from my SNHU class CS 300: Data Structure and Algorithms or DSA: Analysis and Design. This artifact was created in June of 2024, and it is a data structure program that stores bid objects that it generates using a CSV.
</p>
<p>
I selected this artifact to showcase my skill and ability to discern appropriate data structures and algorithmic solutions to a given problem and implement those solutions. The data structure was originally a binary search tree, or BST. I enhanced the artifact and optimized the data structure algorithm by changing it to a B-tree. BSTs and B-trees have an average time complexity of O(log n). However, BSTs can degrade to a time complexity of O(n) in worst case scenarios. These worst-case scenarios can arise based on how data is inserted into the tree, making them unbalanced, or if there is simply a lot of data in the tree. B-trees are self-balancing and store more than one piece of data per node in their tree. This allows them to balance themselves out and maintain a time complexity of O(log n). Given that one of the CSV files in this project contains over 12,000 bids, the B-tree is a big improvement over the binary search tree and makes the data structure more efficient given its dataset. I also enhanced the input function by adding input validation to ensure the program does not error out when the user inputs an invalid command or data type. The input function also provides feedback to the user on what qualifies as proper input.
  </p>
  <p>
I fulfilled the enhancement plan I outlined in Module One and met the requirements for outcome Three, solving a given problem using algorithmic principles and computer science practices appropriate for its solution. I met outcome three by translating the bid program from a BST into a B-tree. I have implemented a B-tree as a solution to the given problem, storing a large dataset of bid objects, after evaluating the trade-offs between the B-tree and the BST.
  </p>
  <p>
The only change in my outcome-coverage plans is that my code review will contribute to course outcomes One and Two. I have met outcomes One: building collaborative environments, outcome Two: of delivering professional-quality communications, and outcome Four: implementing computer solutions with well-founded techniques. These outcomes were met by enhancements in Category One, and my polished code review contributes to outcomes One and Two.
  </p>
  <p>
My code review contributes to outcome One as it demonstrates my ability to employ collaborative code reviews on an individual and team environment. I recorded the code review by myself but with the intention of it being viewed by other people. The code review also meets course outcome Two because I created an orally narrated review adapted to its intended audience, specifically my instructor. I still plan to meet outcome Five, developing a security mindset, with my Category Three enhancements. Aspects of my B-tree program have also contributed to outcome Five, such as the input validation to ensure secure interaction between the program and a user.
  </p>
  <p>
Creating the B-tree was challenging, with the most frequent issue encountered being out-of-bound memory readings which would cause the program to crash. I learned how vital it is to keep good track of the number of objects stored within a given node, to ensure that the program does not try to accidentally access an object or a node that does not exist. I also discovered it was easier to track the treeâ€™s leaves by assigning a Boolean variable to each node. I tried to track leaves by checking that their child pointer arrays were completely null, which required a lot of loop checks and just made things more difficult than they needed to be. I learned that the key to keeping the tree balanced ultimately lay in ensuring bid objects are moved around during insert and removal operations when necessary to maintain a balanced tree.
  </p>
  <p>
The number of times the tree rebalances its nodes and bids occurs more often than I anticipated. I often had to revisit the logic of a given operation and properties B-tree for guidance on proper implementation. The most interesting aspect of B-trees that I learned was how they will rebalance nodes they pass during delete operations if those nodes have too few keys, or bids in my artifacts case. Moving bids around to maintain a certain count within a given node is crucial to maintaining the structure of the B-tree.
  </p>
  <p><a href="https://github.com/KeeganSevener-SNHU/KeeganSevener-SNHU.github.io/tree/main/Category-2-Artifacts/Category%202%20Artifact%20-%20BinarySearchTree">
      Link to original artifact</a></p>
  <p><a href="https://github.com/KeeganSevener-SNHU/KeeganSevener-SNHU.github.io/tree/main/Category-2-Artifacts/Category%202%20Enhanced%20Artifact%20-%20B_Tree-For-Bids%20-%20Keegan%20Sevener">
    Link to enhanced artifact</a></p>