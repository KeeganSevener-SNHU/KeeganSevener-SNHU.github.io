---
title: Keegan's GitHub Page Site
layout: default
---
<body>
<h1>Welcome to Keegan's ePortfolio</h1>
  <h2>Professional Self-Assessment</h2>
  <h3>Code Review</h3>
    <p> <a href="page1.html">Place holder text</a> </p>
  <p><a href="https://www.youtube.com/embed/foJfbRf7J14">My Code Review</a></p>
  
  <h4>Narratives <br> Enhancement One</h4>
    <p>  The artifact for Category One, Software Design and Engineering, is an administrative interface for a fictional website called Travlr Getaways. The artifact is from the CS465 Full Stack Development I course at Southern New Hampshire University and was built earlier this year. The application allows a signed in user to update and create new coral reef trip listings. The application was built in the Angular framework.</p>
  
  <p>  I chose to rebuild this artifact using the React libraries to showcase my expertise in web development and my ability to utilize different web frameworks and libraries. I made several changes to the website’s layout and design to showcase my knowledge and abilities with the React libraries, CSS, and JavaScript. The original artifact’s trip listings were less organized and unappealing to look at. I re-designed the listing cards to be more colorful and formatted them to be more visually appealing. I enhanced the listings by moving most of their information into a modal box that displays more information about each listing. The modal pops up in an animated fashion, and the user does not have to navigate to a new screen to view the information since the modal box opens on the current window. When viewing the modal, the user is presented with a sidebar modal with options to add new listings, edit the current one, or delete the current listing. Clicking on the edit or add button will open a new modal with a form for filling out the information for a new listing or editing the information for the current one. The edit modal form will autofill the input boxes with information from the listing the user was viewing. Another addition was an auto redirect from the main page to the login page. In the original artifact, a user would go to the home page and see all the listing information. The React app will also redirect users who are not logged in to the login page.</p>
  
  <p>When enhancing the artifact, some of the changes I wanted to make required learning some new things. I have worked with HTML modals in the past, but adding the CSS animation was new, but not difficult to learn. I learned about the nuances between Reacts useRef and useState libraries, such as how states will cause the component to re-render, but useRef will not, or how useEffect’s reactive tendencies enabled me to seamlessly set up the redirect function. I used these libraries during testing while developing but only ended up using useEffect in the final product. The knowledge gained on their differences and uses will be valuable moving forward.</p>
  
  <p>Another great lesson was the value of Reacts Context libraries. The createContext and useContext allow me to pass information between React components without prop-drilling. Prop-drilling is a process where variables and functions are passed down through multiple components as ‘properties’, like passing variables into a method. In my React app I pass information into the ListingCard component, which then passes the same information into the MoreInfoCard component. This is an instance prop-drilling that makes sense given that both components need this information. However, if a variable or function needs to be passed to one component, it can be cumbersome to try and pass it down multiple times, not to mention difficult to maintain, and the Context libraries make sharing variables and functions much easier. The challenges I faced in constructing the app were the normal sorts of issues a programmer runs into when developing, such as working out the fine details for margins between text or ensuring the redirect does not continue operating after a user logs in.</p>
  
  <p>I have met the course outcomes that I planned to meet with the planned enhancements to this artifact. The artifact aligns with course outcome One. The Category One artifact features ample code comments that make the code easily readable, understandable, and maintainable without becoming excessive. The admin application is also easy for people to navigate regardless of technical prowess, serving a diverse range of people by not being limited to just the technically savvy person. The artifact aligns with course outcome Two. The code comments clearly articulate the idea and intent behind each component and how they work together to create the web application. The comments are mindful of their audience and assume the reader has familiarity with React. However, the comments are also structured to help programmers with little-to-no knowledge of React quickly understand how the Travlr Getaways admin application works.</p>
  
  <p>Outcome Four is met by the Travlr Getaways application’s utilization of best practices with industry tools such as the React libraries which are common for web development. The application makes good use of HTML, CSS, and JavaScript XML and React to more efficiently deliver the value of the original artifact in a more robust and innovative manner. There are no changes to my outcome-coverage plans. I still plan to meet outcomes Three and Five with the artifacts for Category Two and Category Three respectively. Category Three, Databases, will cover Outcome Five for developing a security mindset. Category Two: Algorithms and Data Structures will fulfill outcome Three with a solution to a given problem using algorithmic principles and computer science practices.</p>
  <br>
  <p><a href="https://github.com/KeeganSevener-SNHU/CS-465">Link to original artifact</a></p>
  <p><a href="https://github.com/KeeganSevener-SNHU/CS465-Enhanced">Link to enhanced artifact</a></p>
  <h4>Enhancement Two</h4>
    <p>For enhancement Category Two, I chose an artifact from my SNHU class CS 300: Data Structure and Algorithms or DSA: Analysis and Design. This artifact was created in June of 2024, and it is a data structure program that stores bid objects that it generates using a CSV.
    </p>
  <p>
    I selected this artifact to showcase my skill and ability to discern appropriate data structures and algorithmic solutions to a given problem and implement those solutions. The data structure was originally a binary search tree, or BST. I enhanced the artifact and optimized the data structure algorithm by changing it to a B-tree. BSTs and B-trees have an average time complexity of O(log n). However, BSTs can degrade to a time complexity of O(n) in worst case scenarios. These worst-case scenarios can arise based on how data is inserted into the tree, making them unbalanced, or if there is simply a lot of data in the tree. B-trees are self-balancing and store more than one piece of data per node in their tree. This allows them to balance themselves out and maintain a time complexity of O(log n). Given that one of the CSV files in this project contains over 12,000 bids, the B-tree is a big improvement over the binary search tree and makes the data structure more efficient given its dataset. I also enhanced the input function by adding input validation to ensure the program does not error out when the user inputs an invalid command or data type. The input function also provides feedback to the user on what qualifies as proper input.
  </p>
  <p>
    I fulfilled the enhancement plan I outlined in Module One and met the requirements for outcome Three by translating the bid program from a BST into a B-tree. I have implemented a B-tree as a solution to the given problem, storing a large dataset of bid objects, after evaluating the trade-offs between the B-tree and the BST.
  </p>
  <p>
    The only change in my outcome-coverage plans is that my code review will contribute to course outcomes One and Two. I have met outcomes One, Two, and Four with the enhancements in Category One, and my polished code review. My code review contributes to outcome One as it demonstrates my ability to employ collaborative code reviews on an individual and team environment. I recorded the code review by myself but with the intention of it being viewed by other people. The code review also meets course outcome Two because I created an orally narrated review adapted to its intended audience, specifically my instructor. I still plan to meet outcome Five, developing a security mindset, with my Category Three enhancements. Aspects of my B-tree program have also contributed to outcome Five, such as the input validation to ensure secure interaction between the program and a user.
  </p>
  <p>
    Creating the B-tree was challenging, with the most frequent issue encountered being out-of-bound memory readings which would cause the program to crash. I learned how vital it is to keep good track of the number of objects stored within a given node, to ensure that the program did not try to accidentally access an object or a node that did not exist. I also discovered it was easier to track the tree’s leaves by assigning a Boolean variable to each node. I tried to track leaves by checking that their child pointer arrays were completely null, which required a lot of loop checks and just made things more difficult than they needed to be. I learned that the key to keeping the tree balanced ultimately lay in ensuring bid objects are moved around during insert and removal operations when necessary to maintain a balanced tree. The number of times the tree rebalances its nodes and bids occur more often than I anticipated. I often had to revisit the logic of a given operation and properties B-tree for guidance on proper implementation. The most interesting aspect of B-trees that I learned was how they will rebalance nodes they pass during delete operations if those nodes have too few keys, or bids in my artifacts case. Moving bids around to maintain a certain count within a given node is crucial to maintaining the structure of the B-tree.
  </p>
  <p><a href="https://github.com/KeeganSevener-SNHU/KeeganSevener-SNHU.github.io/tree/main/Category-2-Artifacts/Category%202%20Artifact%20-%20BinarySearchTree">
      Link to original artifact</a></p>
  <p><a href="https://github.com/KeeganSevener-SNHU/KeeganSevener-SNHU.github.io/tree/main/Category-2-Artifacts/Category%202%20Enhanced%20Artifact%20-%20B_Tree-For-Bids%20-%20Keegan%20Sevener">
    Link to enhanced artifact</a></p>
  
  <h4>Enhancement Three</h4>
    <p>
      	The artifact for Category Three, Databases, is the same one from Category One. This artifact was created earlier this year for class CS 465, Full Stack Development I, at Southern New Hampshire University. The artifact is an administrative application that allows a user to create and update coral reef trip listings in a database and create user accounts. The application sends these requests to a server application programming interface, or API. The API is built in node.js and express. It is the changes to this API which communicates with a MongoDB database that my Category Three enhancements address.
    </p>
  <p>
      I chose this artifact to showcase my ability to develop full fledged communications with databases and limit access to them based on user credentials. Originally, this artifact did not have full CRUD functionality which stands for create, read, update, delete. The original app allows users to view, create, and update new listings but not delete them. I added the delete ability to the enhanced artifact. Additionally, I created custom user roles for the database, so that accounts have roles associated with them. 
  </p>
  <p>
    The role an account has determines what actions that the user can perform. This is known as role-based access control, or RBAC, and it is an authorization scheme. The original artifact had authentication which identifies users, but no authorization schemes to limit the scope of their access. I added an RBAC scheme to vet user authority and determine whether a request they make to the API will be accepted or rejected. I also enhance the artifact by forcing a user to make an account before they can even view the listings. Beforehand, you could just access the API and get a full list of coral reef listings without any authentication.
  </p>
  <p>
    The RBAC scheme was also extended to the front-end developed in Category One for some additional redundant security. If a delete request is sent to the API, it will only perform that action of the user is an authenticated “reactAdmin”. If they do not have that role, then it is rejected. Adding RBAC to the front end takes this to the next level by not even showing the end user the delete button option if they do not have the correct role. Adding this functionality was made easier by updating the JSON Web Token to include user roles in its payload.
  </p>
  <p>
    I have met the course outcome I planned to meet for Category Three, specifically outcome Five of developing a security mindset that addresses potential exploits in software and ensuring privacy and security of data and resources. The implementation of authorization through RBAC to limit access to certain controls like delete operations shows my ability to address design, logic, and structural security flaws. My extension of the authentication requirements to even read operations shows a security mindset, as I am anticipating other ways that people may try to access the API and by extension the database. I can limit what users see in the Travlr front-end, but API requests could be made through Postman or even just a browser tab. By extending the authentication requirements, these requests will be rejected as if they came from my own front-end. Thus, ensuring the level of privacy and security desired for my database.
  </p>
  <p>
     When enhancing the artifact for Category Three, changes needed to be made to both the server API and the front-end React application. I learned to create custom roles within my MongoDB deployment. Upon the successful creation of these roles, I refactored the code for both my server API and the front-end React application to utilize these roles for RBAC. One of the features I was able to utilize for the RBAC controls on the front-end was the fall through principle for switch statements. Since certain roles simply get new functions in addition to lower roles’ abilities, I was able reduce the amount of code by having the switch cases fall through to enable all needed functionality. It is the first time I have found a use for the fall through principle for switch statements.  
  </p>
  <p>
    I also learned how to add additional information to JWT payloads such as the roles array, which was easier than expected. I also learned which React libraries to use for decoding JWTs so that the front-end can make use of the server generated JWTs. When developing the API checks for user roles, I originally planned to create some intermediary functions that would be called before calling the CRUD functions on my API. I ran into some issues with those functions failing to stop the code from proceeding to the CRUD functions given how the controllers are designed. I realized it would be easier to simply put the checks within the CRUD functions and have them return a 401 response if the user did not have the proper authority. It was a good reminder that not everything needs to be compartmentalized. I got the same functionality that I expected, but with less code and just as much security. With RBAC enabled on both the front-end and the back-end, it is now impossible for a user to make any data requests from the MongoDB database unless they’ve been given explicit permission.  
  </p>
  <p><a href="https://github.com/KeeganSevener-SNHU/CS-465">Link to original artifact</a></p>
  <p><a href="https://github.com/KeeganSevener-SNHU/CS465-Enhanced">Link to enhanced artifact</a></p>
</body>
